<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>慢速漂浮 + 碰撞爆炸</title>
  <style>
    body { margin: 0; background: black; overflow: hidden; cursor: crosshair; }
    canvas { display: block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let w = canvas.width = window.innerWidth;
let h = canvas.height = window.innerHeight;

window.addEventListener('resize', () => {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
});

let mouseX = w / 2;
let mouseY = h / 2;
window.addEventListener('mousemove', e => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

const stars = [];
const explosions = [];

function createStar(x = mouseX, y = mouseY) {
  const angle = Math.random() * Math.PI * 10;
  const vx = Math.cos(angle) * 0.5;
  const vy = Math.sin(angle) * 0.05;
  stars.push({
    x, y,
    vx, vy,
    ax: vx * 0.01,
    ay: vy * 0.01,
    size: Math.random() * 1.5 + 0.5,
    color: `hsl(${Math.random() * 180}, 80%, 70%)`
  });
}

function createExplosion(x, y, baseColor) {
  for (let i = 0; i < 6; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 1.2 + 0.5;
    explosions.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 30,
      size: Math.random() * 1.5 + 0.5,
      color: baseColor
    });
  }
}

function draw() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
  ctx.fillRect(0, 0, w, h);

  // 更新並繪製星星
  for (let s of stars) {
    s.vx += s.ax;
    s.vy += s.ay;
    s.x += s.vx;
    s.y += s.vy;
    ctx.beginPath();
    ctx.fillStyle = s.color;
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
  }

  // ⭐⭐ 碰撞偵測與爆炸處理（改成 mark 刪除）
  const minDist = 10;
  const toRemove = new Set();

  for (let i = 0; i < stars.length; i++) {
    const a = stars[i];
    for (let j = i + 1; j < stars.length; j++) {
      const b = stars[j];
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dist = Math.hypot(dx, dy);

      if (dist < minDist) {
        const cx = (a.x + b.x) / 2;
        const cy = (a.y + b.y) / 2;
        createExplosion(cx, cy, a.color);
        toRemove.add(i);
        toRemove.add(j);
      }
    }
  }

  // 移除碰撞星星（從後往前）
  stars
    .map((s, i) => ({ s, i }))
    .filter(obj => !toRemove.has(obj.i))
    .map(obj => obj.s)
    .forEach((s, idx, arr) => stars[idx] = s);
  stars.length = stars.length - toRemove.size;

  // 每幀新增少量新星星
  createStar();
  while (stars.length > 1200) stars.shift();

  // 更新並繪製爆炸粒子
  for (let i = explosions.length - 1; i >= 0; i--) {
    const e = explosions[i];
    e.x += e.vx;
    e.y += e.vy;
    e.life--;
    ctx.beginPath();
    ctx.fillStyle = e.color;
    ctx.globalAlpha = e.life / 50; // 漸淡出
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    if (e.life <= 0) explosions.splice(i, 1);
  }

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
